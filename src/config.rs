#![allow(missing_docs)]
// only because derive(Getters) give me error about functions derived by it do not have docs
// most likely there is better way to do this

use clap::Parser;
use derive_getters::Getters;
use serde::{Serialize, Deserialize};
use termion::{terminal_size};
use crate::{Position, message::Message, colors::{Colors, Color}};
const VERSION: &str = env!("CARGO_PKG_VERSION");

macro_rules! gen_skip_if_default {
    ($field: ident, $type: ty) => {
        paste::item! {
            /// To use with `#[serde(skip_serializing_if = "...")]` annotation on type
            ///
            /// If default value is set and INCLUDE_DEFAULTS_IN_SERIALIZATION is false then it will not be serialized
            ///
            /// Generated by gen_skip_if_default! macro
            fn [< skip_if_default_ $field >]($field: &$type) -> bool {
                if crate::INCLUDE_DEFAULTS_IN_SERIALIZATION.load(std::sync::atomic::Ordering::SeqCst) {
                    return false;
                }
                *$field == Config::default().$field
            }
        }
    }
}

#[derive(Getters, Clone, Serialize, Deserialize)]
#[serde(default)]
/// Structure holding shared configuration of the program
pub struct Config {
    /// Current screen size
    #[serde(skip_serializing_if = "skip_if_default_screen_size")]
    screen_size: Position,
    /// Configured [ColorPair] which will be used by the fallers
    #[serde(skip_serializing_if = "skip_if_default_colors")]
    colors: Colors,
    /// Maximum number of fallers
    #[serde(skip_serializing_if = "skip_if_default_no_fallers")]
    no_fallers: usize,
    /// [String] which characters will be used for displaying [FallingChar] and its trail
    #[serde(skip_serializing_if = "skip_if_default_chars_to_use")]
    chars_to_use: String,
    /// Optional message which will be displayed on the screen
    #[serde(skip_serializing_if = "skip_if_default_message")]
    message: Option<Message>,
}

gen_skip_if_default!(screen_size, Position);
gen_skip_if_default!(colors, Colors);
gen_skip_if_default!(no_fallers, usize);
gen_skip_if_default!(chars_to_use, String);
gen_skip_if_default!(message, Option<Message>);

impl Config {
    /// Create new [Config] instance with default values
    pub fn new_with_defaults() -> Self {
        Default::default()
    }

    /// Parse [Config] from [Cli] (via clap).
    ///
    /// Overwrite defaults with parameters from Cli, or do not if parameter is not present.
    ///
    /// TODO: Evaluate and remove unnecessary clones in this method
    pub fn parse_cli(&mut self) {
        let cli = Cli::parse();

        let size = match (cli.size_x, cli.size_y) {
            (Some(x), Some(y)) => Position { x, y },
            (Some(x), None) => Position { x, ..self.screen_size },
            (None, Some(y)) => Position { y, ..self.screen_size },
            _ => self.screen_size,
        };
        self.screen_size = size;

        let color_trail = match cli.color {
            Some(ref color_str) => match color_str.parse::<u8>() {
                Ok(color) => Color::Palette(color),
                Err(_) => panic!("Incorrect value for color provided: {color_str}"),
            },
            None => self.colors.trail.clone(),
        };
        let color_trail = match cli.color_rgb {
            Some(ref color_str) => {
                let colors_str: Vec<_> = color_str.split(',').collect();
                if colors_str.len() != 3 {
                    panic!("RGB color needs to be specified using following syntax: r,g,b e.g.: 128,128,255");
                }
                let colors_int: Vec<u8> = colors_str.iter().map(|s| s.parse().expect("Cannot convert color value to string")).collect();
                Color::rgb_from_vec(colors_int)
            }
            None => color_trail,
        };
        let colors = if cli.color_rgb.is_some() || cli.color.is_some() {
            Colors {
                head: color_trail.get_alternate_color(),
                trail: color_trail,
            }
        } else {
            self.colors.clone()
        };
        self.colors = colors;

        let no_fallers = match cli.no_fallers {
            Some(no) => match no {
                0 => 1,
                _ => no,
            },
            None => self.no_fallers,
        };
        self.no_fallers = no_fallers;

        let chars_to_use = match cli.chars_to_use {
            Some(str) => str,
            None => self.chars_to_use.clone(),
        };
        self.chars_to_use = chars_to_use;

        let message = cli.message.clone().map(|message_text| {
                Message {
                    position: Position::new_for_centered_text(&size, &message_text)
                        .expect("Cannot use entered message text as it is bigger than screen size!"),
                    text: message_text,
                }
            }
        );
        // New message is present use it
        if message.is_some() {
            if message.clone().unwrap().text.is_empty() {
                self.message = None;
            } else {
                self.message = message;
            }
        // No new message is present, but screen size could have been overwritten by cli params, need to center it again
        } else if self.message.is_some() {
            self.message = self.message.clone().unwrap().clone_centered_or_none(&size)
        }
    }
}

impl Default for Config {
    fn default() -> Self {
        let default_size = terminal_size().expect("Cannot get terminal size!");
        let screen_size = Position { x: default_size.0, y: default_size.1 };
        let message_text = format!("   ruMatrix {VERSION}   ");
        let message = Message::new_centered_or_none(&screen_size, message_text);
        Self {
            screen_size,
            colors: Colors {
                trail: Color::Palette(2),
                head: Color::Palette(10),
            },
            no_fallers: 50,
            chars_to_use: "abcdefghijklmnopqrstuwvxyzABCDEFGHIJKLMNOPQRSTUWVXYZ0123456789!@$%^&*()_+|{}[]<>?!~\\/.,:;".into(),
            message,
        }
    }
}

#[derive(Parser)]
#[command(version)]
#[command(name = "ruMatrix")]
#[command(author = "Piotr Czarny")]
#[command(about = "cmatrix inspired program but in Rust", long_about = None)]
pub struct Cli {
    /// Force width (x) of the screen
    #[arg(long, short = 'x')]
    size_x: Option<u16>,

    /// Force height (y) of the screen
    #[arg(long, short = 'y')]
    size_y: Option<u16>,

    /// Select color (1-8 inclusive) of fallers or 'rnd' for random
    #[arg(long, short = 'c')]
    color: Option<String>,

    /// Select color (r,g,b; 0-255 each) e.g. 50,50,255
    #[arg(long, short = 'C')]
    color_rgb: Option<String>,

    /// Number of fallers
    #[arg(long, short = 'n')]
    no_fallers: Option<usize>,

    /// Chars to use, if not specified use default list
    #[arg(long, short = 'u')]
    chars_to_use: Option<String>,

    /// Message to show on the screen (default: no message)
    #[arg(long = "msg", short = 'm')]
    message: Option<String>,

    /// Print current configuration as YAML - do not include default values
    #[arg(long = "print-config")]
    pub print_config: bool,

    /// Print full current configuration as YAML - do include default values
    #[arg(long = "print-full-config")]
    pub print_full_config: bool,

    /// Load config YAML file from path
    #[arg(long = "config-file", short = 'f')]
    pub config_file: Option<String>,
}


